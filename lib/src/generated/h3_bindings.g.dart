// AUTO-GENERATED by ffigen. Do not edit.
// H3 v4.4.1 â€” https://h3geo.org
// ignore_for_file: type=lint

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: unused_import
@ffi.DefaultAsset('package:h3_core/src/generated/h3_bindings.g.dart')
library;

import 'dart:ffi' as ffi;

/// @defgroup areNeighborCells areNeighborCells
/// Functions for areNeighborCells
/// @{
/// /
/// /** @brief returns whether or not the provided hexagons border
@ffi.Native<H3Error Function(H3Index, H3Index, ffi.Pointer<ffi.Int>)>()
external int areNeighborCells(
  int origin,
  int destination,
  ffi.Pointer<ffi.Int> out,
);

/// @brief exact area for a specific cell (hexagon or pentagon) in kilometers^2
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int cellAreaKm2(int h, ffi.Pointer<ffi.Double> out);

/// @brief exact area for a specific cell (hexagon or pentagon) in meters^2
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int cellAreaM2(int h, ffi.Pointer<ffi.Double> out);

/// @defgroup cellArea cellArea
/// Functions for cellArea
/// @{
/// /
/// /** @brief exact area for a specific cell (hexagon or pentagon) in radians^2
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int cellAreaRads2(int h, ffi.Pointer<ffi.Double> out);

/// @defgroup cellToBoundary cellToBoundary
/// Functions for cellToBoundary
/// @{
/// /
/// /** @brief give the cell boundary in lat/lng coordinates for the cell h3
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<CellBoundary>)>()
external int cellToBoundary(int h3, ffi.Pointer<CellBoundary> gp);

/// @defgroup cellToCenterChild cellToCenterChild
/// Functions for cellToCenterChild
/// @{
/// /
/// /** @brief returns the center child of the given cell at the specified
/// resolution
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int cellToCenterChild(int h, int childRes, ffi.Pointer<H3Index> child);

/// @defgroup cellToChildPos cellToChildPos
/// Functions for cellToChildPos
/// @{
/// /
/// /** @brief Returns the position of the cell within an ordered list of all
/// children of the cell's parent at the specified resolution
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<ffi.Int64>)>()
external int cellToChildPos(
  int child,
  int parentRes,
  ffi.Pointer<ffi.Int64> out,
);

/// @brief provides the children (or grandchildren, etc) of the given cell
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int cellToChildren(int h, int childRes, ffi.Pointer<H3Index> children);

/// @defgroup cellToChildren cellToChildren
/// Functions for cellToChildren
/// @{
/// /
/// /** @brief determines the exact number of children (or grandchildren, etc)
/// that would be returned for the given cell
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<ffi.Int64>)>()
external int cellToChildrenSize(
  int h,
  int childRes,
  ffi.Pointer<ffi.Int64> out,
);

/// @defgroup cellToLatLng cellToLatLng
/// Functions for cellToLatLng
/// @{
/// /
/// /** @brief find the lat/lng center point g of the cell h3
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<LatLng>)>()
external int cellToLatLng(int h3, ffi.Pointer<LatLng> g);

/// @defgroup cellToLocalIj cellToLocalIj
/// Functions for cellToLocalIj
/// @{
/// /
/// /** @brief Returns two dimensional coordinates for the given index
@ffi.Native<
  H3Error Function(H3Index, H3Index, ffi.Uint32, ffi.Pointer<CoordIJ>)
>()
external int cellToLocalIj(
  int origin,
  int h3,
  int mode,
  ffi.Pointer<CoordIJ> out,
);

/// @defgroup cellToParent cellToParent
/// Functions for cellToParent
/// @{
/// /
/// /** @brief returns the parent (or grandparent, etc) cell of the given cell
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int cellToParent(int h, int parentRes, ffi.Pointer<H3Index> parent);

/// @defgroup cellToVertex cellToVertex
/// Functions for cellToVertex
/// @{
/// /
/// /** @brief Returns a single vertex for a given cell, as an H3 index
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int cellToVertex(int origin, int vertexNum, ffi.Pointer<H3Index> out);

/// @defgroup cellToVertexes cellToVertexes
/// Functions for cellToVertexes
/// @{
/// /
/// /** @brief Returns all vertexes for a given cell, as H3 indexes
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<H3Index>)>()
external int cellToVertexes(int origin, ffi.Pointer<H3Index> vertexes);

/// @defgroup cellsToDirectedEdge cellsToDirectedEdge
/// Functions for cellsToDirectedEdge
/// @{
/// /
/// /** @brief returns the directed edge H3Index for the specified origin and
/// destination
@ffi.Native<H3Error Function(H3Index, H3Index, ffi.Pointer<H3Index>)>()
external int cellsToDirectedEdge(
  int origin,
  int destination,
  ffi.Pointer<H3Index> out,
);

/// @defgroup cellsToMultiPolygon cellsToMultiPolygon
/// Functions for cellsToMultiPolygon (currently a binding-only concept)
/// @{
/// /
/// /** @brief Create a LinkedGeoPolygon from a set of contiguous hexagons
@ffi.Native<
  H3Error Function(ffi.Pointer<H3Index>, ffi.Int, ffi.Pointer<LinkedGeoPolygon>)
>()
external int cellsToLinkedMultiPolygon(
  ffi.Pointer<H3Index> h3Set,
  int numHexes,
  ffi.Pointer<LinkedGeoPolygon> out,
);

/// @defgroup childPosToCell childPosToCell
/// Functions for childPosToCell
/// @{
/// /
/// /** @brief Returns the child cell at a given position within an ordered list of
/// all children at the specified resolution
@ffi.Native<
  H3Error Function(ffi.Int64, H3Index, ffi.Int, ffi.Pointer<H3Index>)
>()
external int childPosToCell(
  int childPos,
  int parent,
  int childRes,
  ffi.Pointer<H3Index> child,
);

/// @defgroup compactCells compactCells
/// Functions for compactCells
/// @{
/// /
/// /** @brief compacts the given set of hexagons as best as possible
@ffi.Native<
  H3Error Function(ffi.Pointer<H3Index>, ffi.Pointer<H3Index>, ffi.Int64)
>()
external int compactCells(
  ffi.Pointer<H3Index> h3Set,
  ffi.Pointer<H3Index> compactedSet,
  int numHexes,
);

/// @defgroup constructCell constructCell
/// Functions for constructCell
/// @{
/// /
/// /** @brief create a cell from its components
/// Only allows for constructing valid H3 cells.
@ffi.Native<
  H3Error Function(ffi.Int, ffi.Int, ffi.Pointer<ffi.Int>, ffi.Pointer<H3Index>)
>()
external int constructCell(
  int res,
  int baseCellNumber,
  ffi.Pointer<ffi.Int> digits,
  ffi.Pointer<H3Index> out,
);

/// @defgroup degsToRads degsToRads
/// Functions for degsToRads
/// @{
/// /
/// /** @brief converts degrees to radians
@ffi.Native<ffi.Double Function(ffi.Double)>(isLeaf: true)
external double degsToRads(double degrees);

/// @defgroup describeH3Error describeH3Error
/// Functions for describeH3Error
/// @{
/// /
/// /** @brief converts the provided H3Error value into a description string
@ffi.Native<ffi.Pointer<ffi.Char> Function(H3Error)>()
external ffi.Pointer<ffi.Char> describeH3Error(int err);

/// @brief Free all memory created for a LinkedGeoPolygon
@ffi.Native<ffi.Void Function(ffi.Pointer<LinkedGeoPolygon>)>()
external void destroyLinkedMultiPolygon(ffi.Pointer<LinkedGeoPolygon> polygon);

/// @defgroup directedEdgeToBoundary directedEdgeToBoundary
/// Functions for directedEdgeToBoundary
/// @{
/// /
/// /** @brief Returns the CellBoundary containing the coordinates of the edge
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<CellBoundary>)>()
external int directedEdgeToBoundary(int edge, ffi.Pointer<CellBoundary> gb);

/// @defgroup directedEdgeToCells \
/// directedEdgeToCells
/// Functions for directedEdgeToCells
/// @{
/// /
/// /** @brief Returns the origin and destination hexagons from the directed
/// edge H3Index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<H3Index>)>()
external int directedEdgeToCells(
  int edge,
  ffi.Pointer<H3Index> originDestination,
);

/// @brief exact length for a specific directed edge in kilometers
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int edgeLengthKm(int edge, ffi.Pointer<ffi.Double> length);

/// @brief exact length for a specific directed edge in meters
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int edgeLengthM(int edge, ffi.Pointer<ffi.Double> length);

/// @defgroup edgeLength edgeLength
/// Functions for edgeLength
/// @{
/// /
/// /** @brief exact length for a specific directed edge in radians
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Double>)>()
external int edgeLengthRads(int edge, ffi.Pointer<ffi.Double> length);

/// @defgroup getBaseCellNumber getBaseCellNumber
/// Functions for getBaseCellNumber
/// @{
/// /
/// /** @brief returns the base cell "number" (0 to 121) of the provided H3 cell
///
/// Note: Technically works on H3 edges, but will return base cell of the
/// origin cell.
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int getBaseCellNumber(int h);

/// @defgroup getDirectedEdgeDestination \
/// getDirectedEdgeDestination
/// Functions for getDirectedEdgeDestination
/// @{
/// /
/// /** @brief Returns the destination hexagon H3Index from the directed edge
/// H3Index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<H3Index>)>()
external int getDirectedEdgeDestination(int edge, ffi.Pointer<H3Index> out);

/// @defgroup getDirectedEdgeOrigin \
/// getDirectedEdgeOrigin
/// Functions for getDirectedEdgeOrigin
/// @{
/// /
/// /** @brief Returns the origin hexagon H3Index from the directed edge
/// H3Index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<H3Index>)>()
external int getDirectedEdgeOrigin(int edge, ffi.Pointer<H3Index> out);

/// @defgroup getHexagonAreaAvg getHexagonAreaAvg
/// Functions for getHexagonAreaAvg
/// @{
/// /
/// /** @brief average hexagon area in square kilometers (excludes pentagons)
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Double>)>()
external int getHexagonAreaAvgKm2(int res, ffi.Pointer<ffi.Double> out);

/// @brief average hexagon area in square meters (excludes pentagons)
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Double>)>()
external int getHexagonAreaAvgM2(int res, ffi.Pointer<ffi.Double> out);

/// @defgroup getHexagonEdgeLengthAvg getHexagonEdgeLengthAvg
/// Functions for getHexagonEdgeLengthAvg
/// @{
/// /
/// /** @brief average hexagon edge length in kilometers (excludes pentagons)
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Double>)>()
external int getHexagonEdgeLengthAvgKm(int res, ffi.Pointer<ffi.Double> out);

/// @brief average hexagon edge length in meters (excludes pentagons)
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Double>)>()
external int getHexagonEdgeLengthAvgM(int res, ffi.Pointer<ffi.Double> out);

/// @brief Find all icosahedron faces intersected by a given H3 index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Int>)>()
external int getIcosahedronFaces(int h3, ffi.Pointer<ffi.Int> out);

/// @defgroup getIndexDigit getIndexDigit
/// Functions for getIndexDigit
/// @{
/// /
/// /** @brief returns the indexing digit of the provided H3 cell at a given
/// resolution
///
/// Indexing digits are 1-indexed beginning with the digit for resolution 1.
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<ffi.Int>)>()
external int getIndexDigit(int h, int res, ffi.Pointer<ffi.Int> out);

/// @defgroup getNumCells getNumCells
/// Functions for getNumCells
/// @{
/// /
/// /** @brief number of cells (hexagons and pentagons) for a given resolution
///
/// It works out to be `2 + 120*7^r` for resolution `r`.
///
/// # Mathematical notes
///
/// Let h(n) be the number of children n levels below
/// a single *hexagon*.
///
/// Then h(n) = 7^n.
///
/// Let p(n) be the number of children n levels below
/// a single *pentagon*.
///
/// Then p(0) = 1, and p(1) = 6, since each pentagon
/// has 5 hexagonal immediate children and 1 pentagonal
/// immediate child.
///
/// In general, we have the recurrence relation
///
/// p(n) = 5*h(n-1) + p(n-1)
/// = 5*7^(n-1) + p(n-1).
///
/// Working through the recurrence, we get that
///
/// p(n) = 1 + 5*\sum_{k=1}^n 7^{k-1}
/// = 1 + 5*(7^n - 1)/6,
///
/// using the closed form for a geometric series.
///
/// Using the closed forms for h(n) and p(n), we can
/// get a closed form for the total number of cells
/// at resolution r:
///
/// c(r) = 12*p(r) + 110*h(r)
/// = 2 + 120*7^r.
///
///
/// @param   res  H3 cell resolution
///
/// @return       number of cells at resolution `res`
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Int64>)>()
external int getNumCells(int res, ffi.Pointer<ffi.Int64> out);

/// @brief generates all pentagons at the specified resolution
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<H3Index>)>()
external int getPentagons(int res, ffi.Pointer<H3Index> out);

/// @brief provides all base cells in H3Index format
@ffi.Native<H3Error Function(ffi.Pointer<H3Index>)>()
external int getRes0Cells(ffi.Pointer<H3Index> out);

/// @defgroup getResolution getResolution
/// Functions for getResolution
/// @{
/// /
/// /** @brief returns the resolution of the provided H3 index
/// Works on both cells and directed edges.
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int getResolution(int h);

/// @brief "great circle distance" between pairs of LatLng points in
/// kilometers
@ffi.Native<ffi.Double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>()
external double greatCircleDistanceKm(
  ffi.Pointer<LatLng> a,
  ffi.Pointer<LatLng> b,
);

/// @brief "great circle distance" between pairs of LatLng points in meters
@ffi.Native<ffi.Double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>()
external double greatCircleDistanceM(
  ffi.Pointer<LatLng> a,
  ffi.Pointer<LatLng> b,
);

/// @defgroup greatCircleDistance greatCircleDistance
/// Functions for distance
/// @{
/// /
/// /** @brief "great circle distance" between pairs of LatLng points in radians
@ffi.Native<ffi.Double Function(ffi.Pointer<LatLng>, ffi.Pointer<LatLng>)>()
external double greatCircleDistanceRads(
  ffi.Pointer<LatLng> a,
  ffi.Pointer<LatLng> b,
);

/// @brief hexagon neighbors in all directions
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int gridDisk(int origin, int k, ffi.Pointer<H3Index> out);

/// @defgroup gridDiskDistances gridDiskDistances
/// Functions for gridDiskDistances
/// @{
/// /
/// /** @brief hexagon neighbors in all directions, reporting distance from origin
@ffi.Native<
  H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>, ffi.Pointer<ffi.Int>)
>()
external int gridDiskDistances(
  int origin,
  int k,
  ffi.Pointer<H3Index> out,
  ffi.Pointer<ffi.Int> distances,
);

/// @brief hexagons neighbors in all directions reporting distance from origin
@ffi.Native<
  H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>, ffi.Pointer<ffi.Int>)
>()
external int gridDiskDistancesSafe(
  int origin,
  int k,
  ffi.Pointer<H3Index> out,
  ffi.Pointer<ffi.Int> distances,
);

/// @brief hexagons neighbors in all directions, assuming no pentagons,
/// reporting distance from origin
@ffi.Native<
  H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>, ffi.Pointer<ffi.Int>)
>()
external int gridDiskDistancesUnsafe(
  int origin,
  int k,
  ffi.Pointer<H3Index> out,
  ffi.Pointer<ffi.Int> distances,
);

/// @brief hexagons neighbors in all directions, assuming no pentagons
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int gridDiskUnsafe(int origin, int k, ffi.Pointer<H3Index> out);

/// @defgroup gridDistance gridDistance
/// Functions for gridDistance
/// @{
/// /
/// /** @brief Returns grid distance between two indexes
@ffi.Native<H3Error Function(H3Index, H3Index, ffi.Pointer<ffi.Int64>)>()
external int gridDistance(int origin, int h3, ffi.Pointer<ffi.Int64> distance);

/// @brief Line of h3 indexes connecting two indexes
@ffi.Native<H3Error Function(H3Index, H3Index, ffi.Pointer<H3Index>)>()
external int gridPathCells(int start, int end, ffi.Pointer<H3Index> out);

/// @defgroup gridPathCells gridPathCells
/// Functions for gridPathCells
/// @{
/// /
/// /** @brief Number of indexes in a line connecting two indexes
@ffi.Native<H3Error Function(H3Index, H3Index, ffi.Pointer<ffi.Int64>)>()
external int gridPathCellsSize(int start, int end, ffi.Pointer<ffi.Int64> size);

/// @brief hollow hexagon ring k distance from origin
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int gridRing(int origin, int k, ffi.Pointer<H3Index> out);

/// @brief hollow hexagon ring k distance from origin
@ffi.Native<H3Error Function(H3Index, ffi.Int, ffi.Pointer<H3Index>)>()
external int gridRingUnsafe(int origin, int k, ffi.Pointer<H3Index> out);

/// @defgroup h3ToString h3ToString
/// Functions for h3ToString
/// @{
/// /
/// /** @brief converts an H3Index to a canonical string
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Char>, ffi.Size)>()
external int h3ToString(int h, ffi.Pointer<ffi.Char> str, int sz);

/// @defgroup isPentagon isPentagon
/// Functions for isPentagon
/// @{
/// /
/// /** @brief determines if an H3 cell is a pentagon
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int isPentagon(int h);

/// @defgroup isResClassIII isResClassIII
/// Functions for isResClassIII
/// @{
/// /
/// /** @brief determines if a hexagon is Class III (or Class II)
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int isResClassIII(int h);

/// @defgroup isValidCell isValidCell
/// Functions for isValidCell
/// @{
/// /
/// /** @brief confirms if an H3Index is a valid cell (hexagon or pentagon)
/// In particular, returns 0 (False) for H3 directed edges or invalid data
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int isValidCell(int h);

/// @defgroup isValidDirectedEdge isValidDirectedEdge
/// Functions for isValidDirectedEdge
/// @{
/// /
/// /** @brief returns whether the H3Index is a valid directed edge
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int isValidDirectedEdge(int edge);

/// @defgroup isValidIndex isValidIndex
/// Functions for isValidIndex
/// @{
/// /
/// /** @brief confirms if an H3Index is valid for any mode (cell, directed edge, or
/// vertex) Returns 1 if the H3 index is valid for any supported type, 0
/// otherwise
@ffi.Native<ffi.Int Function(H3Index)>()
external int isValidIndex(int h);

/// @defgroup isValidVertex isValidVertex
/// Functions for isValidVertex
/// @{
/// /
/// /** @brief Whether the input is a valid H3 vertex
@ffi.Native<ffi.Int Function(H3Index)>(isLeaf: true)
external int isValidVertex(int vertex);

/// @defgroup latLngToCell latLngToCell
/// Functions for latLngToCell
/// @{
/// /
/// /** @brief find the H3 index of the resolution res cell containing the lat/lng
@ffi.Native<
  H3Error Function(ffi.Pointer<LatLng>, ffi.Int, ffi.Pointer<H3Index>)
>()
external int latLngToCell(
  ffi.Pointer<LatLng> g,
  int res,
  ffi.Pointer<H3Index> out,
);

/// @defgroup localIjToCell localIjToCell
/// Functions for localIjToCell
/// @{
/// /
/// /** @brief Returns index for the given two dimensional coordinates
@ffi.Native<
  H3Error Function(
    H3Index,
    ffi.Pointer<CoordIJ>,
    ffi.Uint32,
    ffi.Pointer<H3Index>,
  )
>()
external int localIjToCell(
  int origin,
  ffi.Pointer<CoordIJ> ij,
  int mode,
  ffi.Pointer<H3Index> out,
);

/// @defgroup getIcosahedronFaces getIcosahedronFaces
/// Functions for getIcosahedronFaces
/// @{
/// /
/// /** @brief Max number of icosahedron faces intersected by an index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<ffi.Int>)>()
external int maxFaceCount(int h3, ffi.Pointer<ffi.Int> out);

/// @defgroup gridDisk gridDisk
/// Functions for gridDisk
/// @{
/// /
/// /** @brief maximum number of hexagons in k-ring
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Int64>)>()
external int maxGridDiskSize(int k, ffi.Pointer<ffi.Int64> out);

/// @defgroup gridRing gridRing
/// Functions for gridRing
/// @{
/// /
/// /** @brief maximum number of hexagons in hollow k-ring
@ffi.Native<H3Error Function(ffi.Int, ffi.Pointer<ffi.Int64>)>()
external int maxGridRingSize(int k, ffi.Pointer<ffi.Int64> out);

/// @defgroup polygonToCells polygonToCells
/// Functions for polygonToCells
/// @{
/// /
/// /** @brief maximum number of cells that could be in the polygon
@ffi.Native<
  H3Error Function(
    ffi.Pointer<GeoPolygon>,
    ffi.Int,
    ffi.Uint32,
    ffi.Pointer<ffi.Int64>,
  )
>()
external int maxPolygonToCellsSize(
  ffi.Pointer<GeoPolygon> geoPolygon,
  int res,
  int flags,
  ffi.Pointer<ffi.Int64> out,
);

/// @defgroup polygonToCellsExperimental polygonToCellsExperimental
/// Functions for polygonToCellsExperimental.
/// This is an experimental-only API and is subject to change in minor versions.
/// @{
/// /
/// /** @brief maximum number of cells that could be in the polygon
@ffi.Native<
  H3Error Function(
    ffi.Pointer<GeoPolygon>,
    ffi.Int,
    ffi.Uint32,
    ffi.Pointer<ffi.Int64>,
  )
>()
external int maxPolygonToCellsSizeExperimental(
  ffi.Pointer<GeoPolygon> polygon,
  int res,
  int flags,
  ffi.Pointer<ffi.Int64> out,
);

/// @defgroup originToDirectedEdges \
/// originToDirectedEdges
/// Functions for originToDirectedEdges
/// @{
/// /
/// /** @brief Returns the 6 (or 5 for pentagons) edges associated with the H3Index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<H3Index>)>()
external int originToDirectedEdges(int origin, ffi.Pointer<H3Index> edges);

/// @defgroup getPentagons getPentagons
/// Functions for getPentagons
/// @{
/// /
/// /** @brief returns the number of pentagons per resolution
@ffi.Native<ffi.Int Function()>(isLeaf: true)
external int pentagonCount();

/// @brief cells within the given polygon
@ffi.Native<
  H3Error Function(
    ffi.Pointer<GeoPolygon>,
    ffi.Int,
    ffi.Uint32,
    ffi.Pointer<H3Index>,
  )
>()
external int polygonToCells(
  ffi.Pointer<GeoPolygon> geoPolygon,
  int res,
  int flags,
  ffi.Pointer<H3Index> out,
);

/// @brief cells within the given polygon
@ffi.Native<
  H3Error Function(
    ffi.Pointer<GeoPolygon>,
    ffi.Int,
    ffi.Uint32,
    ffi.Int64,
    ffi.Pointer<H3Index>,
  )
>()
external int polygonToCellsExperimental(
  ffi.Pointer<GeoPolygon> polygon,
  int res,
  int flags,
  int size,
  ffi.Pointer<H3Index> out,
);

/// @defgroup radsToDegs radsToDegs
/// Functions for radsToDegs
/// @{
/// /
/// /** @brief converts radians to degrees
@ffi.Native<ffi.Double Function(ffi.Double)>(isLeaf: true)
external double radsToDegs(double radians);

/// @defgroup getRes0Cells getRes0Cells
/// Functions for getRes0Cells
/// @{
/// /
/// /** @brief returns the number of resolution 0 cells (hexagons and pentagons)
@ffi.Native<ffi.Int Function()>(isLeaf: true)
external int res0CellCount();

/// @defgroup stringToH3 stringToH3
/// Functions for stringToH3
/// @{
/// /
/// /** @brief converts the canonical string format to H3Index format
@ffi.Native<H3Error Function(ffi.Pointer<ffi.Char>, ffi.Pointer<H3Index>)>()
external int stringToH3(ffi.Pointer<ffi.Char> str, ffi.Pointer<H3Index> out);

/// @brief uncompacts the compacted hexagon set
@ffi.Native<
  H3Error Function(
    ffi.Pointer<H3Index>,
    ffi.Int64,
    ffi.Pointer<H3Index>,
    ffi.Int64,
    ffi.Int,
  )
>()
external int uncompactCells(
  ffi.Pointer<H3Index> compactedSet,
  int numCompacted,
  ffi.Pointer<H3Index> outSet,
  int numOut,
  int res,
);

/// @defgroup uncompactCells uncompactCells
/// Functions for uncompactCells
/// @{
/// /
/// /** @brief determines the exact number of hexagons that will be uncompacted
/// from the compacted set
@ffi.Native<
  H3Error Function(
    ffi.Pointer<H3Index>,
    ffi.Int64,
    ffi.Int,
    ffi.Pointer<ffi.Int64>,
  )
>()
external int uncompactCellsSize(
  ffi.Pointer<H3Index> compactedSet,
  int numCompacted,
  int res,
  ffi.Pointer<ffi.Int64> out,
);

/// @defgroup vertexToLatLng vertexToLatLng
/// Functions for vertexToLatLng
/// @{
/// /
/// /** @brief Returns a single vertex for a given cell, as an H3 index
@ffi.Native<H3Error Function(H3Index, ffi.Pointer<LatLng>)>()
external int vertexToLatLng(int vertex, ffi.Pointer<LatLng> point);

/// @struct CellBoundary
/// @brief cell boundary in latitude/longitude
final class CellBoundary extends ffi.Struct {
  /// < number of vertices
  @ffi.Int()
  external int numVerts;

  /// < vertices in ccw order
  @ffi.Array.multi([10])
  external ffi.Array<LatLng> verts;
}

/// Values representing polyfill containment modes, to be used in
/// the `flags` bit field for `polygonToCellsExperimental`.
sealed class ContainmentMode {
  /// < Cell center is contained in the shape
  static const CONTAINMENT_CENTER = 0;

  /// < Cell is fully contained in the shape
  static const CONTAINMENT_FULL = 1;

  /// < Cell overlaps the shape at any point
  static const CONTAINMENT_OVERLAPPING = 2;

  /// < Cell bounding box overlaps shape
  static const CONTAINMENT_OVERLAPPING_BBOX = 3;

  /// < This mode is invalid and should not be used
  static const CONTAINMENT_INVALID = 4;
}

/// @struct CoordIJ
/// @brief IJ hexagon coordinates
///
/// Each axis is spaced 120 degrees apart.
final class CoordIJ extends ffi.Struct {
  /// < i component
  @ffi.Int()
  external int i;

  /// < j component
  @ffi.Int()
  external int j;
}

/// @struct GeoLoop
/// @brief similar to CellBoundary, but requires more alloc work
final class GeoLoop extends ffi.Struct {
  @ffi.Int()
  external int numVerts;

  external ffi.Pointer<LatLng> verts;
}

/// @struct GeoMultiPolygon
/// @brief Simplified core of GeoJSON MultiPolygon coordinates definition
final class GeoMultiPolygon extends ffi.Struct {
  @ffi.Int()
  external int numPolygons;

  external ffi.Pointer<GeoPolygon> polygons;
}

/// @struct GeoPolygon
/// @brief Simplified core of GeoJSON Polygon coordinates definition
final class GeoPolygon extends ffi.Struct {
  /// < exterior boundary of the polygon
  external GeoLoop geoloop;

  /// < number of elements in the array pointed to by holes
  @ffi.Int()
  external int numHoles;

  /// < interior boundaries (holes) in the polygon
  external ffi.Pointer<GeoLoop> holes;
}

/// @brief Result code (success or specific error) from an H3 operation
typedef H3Error = ffi.Uint32;
typedef DartH3Error = int;

sealed class H3ErrorCodes {
  static const E_SUCCESS = 0;
  static const E_FAILED = 1;
  static const E_DOMAIN = 2;
  static const E_LATLNG_DOMAIN = 3;
  static const E_RES_DOMAIN = 4;
  static const E_CELL_INVALID = 5;
  static const E_DIR_EDGE_INVALID = 6;
  static const E_UNDIR_EDGE_INVALID = 7;
  static const E_VERTEX_INVALID = 8;
  static const E_PENTAGON = 9;
  static const E_DUPLICATE_INPUT = 10;
  static const E_NOT_NEIGHBORS = 11;
  static const E_RES_MISMATCH = 12;
  static const E_MEMORY_ALLOC = 13;
  static const E_MEMORY_BOUNDS = 14;
  static const E_OPTION_INVALID = 15;
  static const E_INDEX_INVALID = 16;
  static const E_BASE_CELL_DOMAIN = 17;
  static const E_DIGIT_DOMAIN = 18;
  static const E_DELETED_DIGIT = 19;
  static const H3_ERROR_END = 20;
}

/// @brief Identifier for an object (cell, edge, etc) in the H3 system.
///
/// The H3Index fits within a 64-bit unsigned integer.
typedef H3Index = ffi.Uint64;
typedef DartH3Index = int;

const int H3_NULL = 0;

/// @struct LatLng
/// @brief latitude/longitude in radians
final class LatLng extends ffi.Struct {
  /// < latitude in radians
  @ffi.Double()
  external double lat;

  /// < longitude in radians
  @ffi.Double()
  external double lng;
}

final class LinkedGeoLoop extends ffi.Struct {
  external ffi.Pointer<LinkedLatLng> first;

  external ffi.Pointer<LinkedLatLng> last;

  external ffi.Pointer<LinkedGeoLoop> next;
}

final class LinkedGeoPolygon extends ffi.Struct {
  external ffi.Pointer<LinkedGeoLoop> first;

  external ffi.Pointer<LinkedGeoLoop> last;

  external ffi.Pointer<LinkedGeoPolygon> next;
}

final class LinkedLatLng extends ffi.Struct {
  external LatLng vertex;

  external ffi.Pointer<LinkedLatLng> next;
}

const int MAX_CELL_BNDRY_VERTS = 10;
